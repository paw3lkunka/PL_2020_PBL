
auto standardPbrShader = objectModule.newShader("standardPbr", "Resources/Shaders/StandardPBR/StandardPBR.vert", "Resources/Shaders/StandardPBR/StandardPBR.frag");
auto flowmapShader = objectModule.newShader("flowmapShader", "Resources/Shaders/FlowmapWater/FlowmapWater.vert", "Resources/Shaders/FlowmapWater/FlowmapWater.frag");
auto unlitColor = objectModule.newShader("UnlitColor", "Resources/Shaders/UnlitColor/UnlitColor.vert", "Resources/Shaders/UnlitColor/UnlitColor.frag");

TextureCreateInfo texCreateInfo = {};
texCreateInfo.generateMipmaps = true;
texCreateInfo.magFilter = GL_LINEAR;
texCreateInfo.minFilter = GL_LINEAR_MIPMAP_LINEAR;
texCreateInfo.wrapMode = GL_REPEAT;

auto water1Diffuse = objectModule.newTexture("Resources/Textures/Unity/water_diffuse.png", texCreateInfo);
auto water1Normal = objectModule.newTexture("Resources/Textures/Unity/water_normal.png", texCreateInfo);
auto emptyOccRouMet = objectModule.newTexture("Resources/Textures/Unity/water_occroumet.png", texCreateInfo);
//auto water1OccRouSpec = objectModule.newTexture("Resources/Textures/water/Water_001_OccRouSpec.png", texCreateInfo);
auto flowmap = objectModule.newTexture("Resources/Flowmaps/flowmap.png", texCreateInfo);
auto noise = objectModule.newTexture("Resources/Flowmaps/noiseTexture.png", texCreateInfo);

Material* waterMat = objectModule.newMaterial(flowmapShader, "waterMat", RenderType::Transparent);
waterMat->setTexture("diffuse", water1Diffuse);
waterMat->setTexture("normal", water1Normal);
waterMat->setTexture("occRouMet", emptyOccRouMet);
waterMat->setTexture("flowMap", flowmap);
waterMat->setVec2("channelFlowDirection", {-1.0f, 1.0f});
waterMat->setFloat("blendCycle", 1.0f);
waterMat->setFloat("cycleSpeed", 1.0f);
waterMat->setFloat("flowSpeed", 0.5f);
waterMat->setTexture("flowMapNoise", noise);
waterMat->setVec2("flowNoiseSize", {1.0f, 1.0f});
waterMat->setFloat("flowNoiseInfluence", 0.5f);
waterMat->setVec2("uvScale", {1.0f, 1.0f});

objectModule.newModel("Resources/Models/Plane.obj");
{
    Entity* waterPlane0 = objectModule.getEntityPtrByName("Plane.obj/Plane");
    auto mr = waterPlane0->getComponentPtr<MeshRenderer>();
        mr->material = waterMat;

    auto t = waterPlane0->getComponentPtr<Transform>();
        t->getLocalPositionModifiable() = {50.0f, 0.0f, -50.0f};
}

TextureCreateInfo i = {};
i.minFilter = GL_LINEAR;
i.magFilter = GL_LINEAR;
i.wrapMode= GL_CLAMP_TO_EDGE;
i.generateMipmaps = false;
CubemapHdr* hdrCubemap = objectModule.newHdrCubemap(i,  "Resources/Textures/skybox_02/nz.hdr", 
                                                        "Resources/Textures/skybox_02/nx.hdr", 
                                                        "Resources/Textures/skybox_02/px.hdr",
                                                        "Resources/Textures/skybox_02/pz.hdr",
                                                        "Resources/Textures/skybox_02/py.hdr",
                                                        "Resources/Textures/skybox_02/ny.hdr");

Shader* skyboxShader = objectModule.newShader("skyboxShader", "Resources/Shaders/SkyboxCubemap/SkyboxCubemap.vert", "Resources/Shaders/SkyboxCubemap/SkyboxCubemap.frag");

Material* hdrSkyboxMat = objectModule.newMaterial(skyboxShader, "skyboxHdrMat", RenderType::Opaque);
hdrSkyboxMat->setTexture("cubemap", hdrCubemap);
rendererModule.setSkybox(hdrSkyboxMat);

objectModule.newEntity(2, "directionalLight");
{
    auto t = objectModule.newEmptyComponentForLastEntity<Transform>();
        t->getLocalRotationModifiable() *= glm::angleAxis(glm::radians(150.0f) , glm::vec3(0.0f, 1.0f, 0.0f));
        t->getLocalRotationModifiable() *= glm::angleAxis(glm::radians(21.5f) , glm::vec3(1.0f, 0.0f, 0.0f));
        t->setParent(&sceneModule.rootNode);

    auto l = objectModule.newEmptyComponentForLastEntity<Light>();
        l->lightType = LightType::Directional;
        l->intensity = 3.0f;
        l->color = {1.0f, 0.8f, 0.35f};
}

objectModule.newEntity(4, "Camera");
{
    auto c = objectModule.newEmptyComponentForLastEntity<Camera>();
    ViewFrustum& frustum = c->getFrustumModifiable();
        frustum.farPlane = 2500.0f;
        frustum.nearPlane = 0.1f;
        frustum.fieldOfView = 80.0f;
        frustum.aspectRatio = (float)GetCore().windowWidth / (float)GetCore().windowHeight;
        c->getProjectionModeModifiable() = CameraProjection::Perspective;

    auto t = objectModule.newEmptyComponentForLastEntity<Transform>();
        t->getLocalPositionModifiable() = glm::vec3(0.0f, 0.0f, 0.0f);
        t->setParent(&sceneModule.rootNode);

    auto li = objectModule.newEmptyComponentForLastEntity<AudioListener>();
        li->getIsCurrentModifiable() = true;
        li->getGainModifiable() = 1.0f;
        li->getVelocityModifiable();
        li->getPositionModifiable();
        li->getAtModifiable();
        li->getUpModifiable();
}

{
    objectModule.newModel("Resources/Models/Kayak_low_poly.FBX");
    Entity* paddleIndirect = objectModule.newEntity(1, "PaddleIndirect");
    {
        auto t = objectModule.newEmptyComponentForLastEntity<Transform>();
            t->setParent(objectModule.getEntityPtrByName("Kayak_low_poly.FBX/Kayak")->getComponentPtr<Transform>());
            //(objectModule.getEntityPtrByName("Player")->getComponentPtr<Transform>());
            t->getLocalRotationModifiable() = eulerToQuaternion(glm::vec3(0.0f, 180.0f, 180.0f));
            t->getLocalPositionModifiable() = glm::vec3(0.0f, 0.25f, 1.0f);
    }

    Material* paddleMat = objectModule.newMaterial(unlitColor, "paddleMat", RenderType::Opaque);
    paddleMat->setVec4("color", glm::vec4(0.670f, 0.427f, 0.109f, 1.0f));
    {
        auto entity = objectModule.getEntityPtrByName("Kayak_low_poly.FBX/Paddle");
        auto mr = entity->getComponentPtr<MeshRenderer>();
            mr->material = paddleMat;

        auto t = entity->getComponentPtr<Transform>();
            t->setParent(paddleIndirect->getComponentPtr<Transform>());

        auto paddle = objectModule.newEmptyComponent<Paddle>();
            paddle->maxPos = glm::vec3(-0.45f, 0.9f, -1.75f);
            paddle->maxFrontRot = -34.5f;
            paddle->maxSideRot = 30.0f;
            entity->addComponent(paddle);
    }

    Material* kayakMat = objectModule.newMaterial(unlitColor, "kayakMat", RenderType::Opaque);
    kayakMat->setVec4("color", glm::vec4(0.152f, 0.866f, 0.772f, 1.0f));
    {
        auto entity = objectModule.getEntityPtrByName("Kayak_low_poly.FBX/Kayak");
        auto mr = entity->getComponentPtr<MeshRenderer>();
            mr->material = kayakMat;

        auto t = entity->getComponentPtr<Transform>();
            t->getLocalRotationModifiable() = eulerToQuaternion(glm::vec3(-90, 0, 0));
            t->getLocalPositionModifiable() = glm::vec3(-13, 0, -55);
            t->getLocalScaleModifiable() = glm::vec3(1.0f, 1.0f, 1.0f);
            t->setParent(&sceneModule.rootNode);
    }

    // KAYAK MAN
    auto kayakRigidbody = objectModule.newEmptyComponent<Rigidbody>();
        kayakRigidbody->drag = 0.2f;
        kayakRigidbody->angularDrag = 0.1f;
        kayakRigidbody->mass = 150.0f;
        kayakRigidbody->ignoreGravity = false;

    auto kayakBoxCollider = objectModule.newEmptyComponent<BoxCollider>();
        kayakBoxCollider->halfSize = glm::vec3(5.0f, 15.0f, 2.0f);

    auto kayakHydroBody = objectModule.newEmptyComponent<HydroBody>();
    
    auto kayakPtr = objectModule.getEntityPtrByName("Kayak_low_poly.FBX/Kayak");
        kayakPtr->addComponent(kayakHydroBody);
        kayakPtr->addComponent(kayakRigidbody);
        kayakPtr->addComponent(kayakBoxCollider);

    // PADDLE MAN
    auto paddleHydroAccelerator = objectModule.newEmptyComponent<HydroAccelerator>();
        paddleHydroAccelerator->rigidbody = kayakRigidbody;
    auto paddleHydroBody = objectModule.newEmptyComponent<HydroBody>();

    auto paddlePtr = objectModule.getEntityPtrByName("Kayak_low_poly.FBX/Paddle");
        paddlePtr->addComponent(paddleHydroAccelerator);
        paddlePtr->addComponent(paddleHydroBody);
}

{
    auto kayakPtr = objectModule.getEntityPtrByName("Kayak_low_poly.FBX/Kayak");

    auto tpCameraPtr = objectModule.newEmptyComponent<ThirdPersonCamera>();
        tpCameraPtr->player = kayakPtr->getComponentPtr<Transform>();
        //tpCameraPtr->playerRigidbody = kayakPtr->getComponentPtr<Rigidbody>();

    auto fpCameraPtr = objectModule.newEmptyComponent<FirstPersonCamera>();
        fpCameraPtr->player = kayakPtr->getComponentPtr<Transform>();

    auto cameraPtr = objectModule.getEntityPtrByName("Camera");
        cameraPtr->addComponent(tpCameraPtr);
        cameraPtr->addComponent(fpCameraPtr);
        cameraPtr->getComponentPtr<Camera>()->control = CameraControl::ThirdPerson;
}

TerrainUtils::loadAllTerrainChunks();
TerrainUtils::createMaterialsForModels();
TerrainUtils::loadExportedUnityModels();