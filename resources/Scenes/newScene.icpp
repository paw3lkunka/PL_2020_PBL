
auto standardPbrShader = objectModule.newShader("standardPbr", "Resources/Shaders/StandardPBR/StandardPBR.vert", "Resources/Shaders/StandardPBR/StandardPBR.frag");
auto flowmapShader = objectModule.newShader("flowmapShader", "Resources/Shaders/FlowmapWater/FlowmapWater.vert", "Resources/Shaders/FlowmapWater/FlowmapWater.frag");
auto unlitColor = objectModule.newShader("UnlitColor", "Resources/Shaders/UnlitColor/UnlitColor.vert", "Resources/Shaders/UnlitColor/UnlitColor.frag");

TextureCreateInfo texCreateInfo = {};
texCreateInfo.generateMipmaps = true;
texCreateInfo.magFilter = GL_LINEAR;
texCreateInfo.minFilter = GL_LINEAR_MIPMAP_LINEAR;
texCreateInfo.wrapMode = GL_REPEAT;

auto water1Diffuse = objectModule.newTexture("Resources/Textures/Unity/water_diffuse.png", texCreateInfo);
auto water1Normal = objectModule.newTexture("Resources/Textures/Unity/water_normal.png", texCreateInfo);
auto emptyOccRouMet = objectModule.newTexture("Resources/Textures/Unity/water_occroumet.png", texCreateInfo);
//auto water1OccRouSpec = objectModule.newTexture("Resources/Textures/water/Water_001_OccRouSpec.png", texCreateInfo);
auto flowmap = objectModule.newTexture("Resources/Flowmaps/flowmap.png", texCreateInfo);
auto noise = objectModule.newTexture("Resources/Flowmaps/noiseTexture.png", texCreateInfo);

Material* waterMat = objectModule.newMaterial(flowmapShader, "waterMat", RenderType::Transparent);
waterMat->setTexture("diffuse", water1Diffuse);
waterMat->setTexture("normal", water1Normal);
waterMat->setTexture("occRouMet", emptyOccRouMet);
waterMat->setTexture("flowMap", flowmap);
waterMat->setVec2("channelFlowDirection", {-1.0f, 1.0f});
waterMat->setFloat("blendCycle", 1.0f);
waterMat->setFloat("cycleSpeed", 1.0f);
waterMat->setFloat("flowSpeed", 0.5f);
waterMat->setTexture("flowMapNoise", noise);
waterMat->setVec2("flowNoiseSize", {1.0f, 1.0f});
waterMat->setFloat("flowNoiseInfluence", 0.5f);
waterMat->setVec2("uvScale", {1.0f, 1.0f});

//objectModule.newModel("Resources/Models/unit_sphere.FBX");

objectModule.newModel("Resources/Models/Plane.obj");
{
    Entity* waterPlane0 = objectModule.getEntityPtrByName("Plane.obj/Plane");
    auto mr = waterPlane0->getComponentPtr<MeshRenderer>();
        mr->material = waterMat;

    auto t = waterPlane0->getComponentPtr<Transform>();
        t->getLocalPositionModifiable() = {50.0f, 0.0f, -50.0f};
}

TextureCreateInfo i = {};
i.minFilter = GL_LINEAR;
i.magFilter = GL_LINEAR;
i.wrapMode= GL_CLAMP_TO_EDGE;
i.generateMipmaps = false;
CubemapHdr* hdrCubemap = objectModule.newHdrCubemap(i,  "Resources/Textures/skybox_02/nz.hdr", 
                                                        "Resources/Textures/skybox_02/nx.hdr", 
                                                        "Resources/Textures/skybox_02/px.hdr",
                                                        "Resources/Textures/skybox_02/pz.hdr",
                                                        "Resources/Textures/skybox_02/py.hdr",
                                                        "Resources/Textures/skybox_02/ny.hdr");

Shader* skyboxShader = objectModule.newShader("skyboxShader", "Resources/Shaders/SkyboxCubemap/SkyboxCubemap.vert", "Resources/Shaders/SkyboxCubemap/SkyboxCubemap.frag");

Material* hdrSkyboxMat = objectModule.newMaterial(skyboxShader, "skyboxHdrMat", RenderType::Opaque);
hdrSkyboxMat->setTexture("cubemap", hdrCubemap);
rendererModule.setSkybox(hdrSkyboxMat);

objectModule.newEntity(2, "directionalLight");
{
    auto t = objectModule.newEmptyComponentForLastEntity<Transform>();
        t->getLocalRotationModifiable() *= glm::angleAxis(glm::radians(150.0f) , glm::vec3(0.0f, 1.0f, 0.0f));
        t->getLocalRotationModifiable() *= glm::angleAxis(glm::radians(21.5f) , glm::vec3(1.0f, 0.0f, 0.0f));
        t->setParent(&sceneModule.rootNode);

    auto l = objectModule.newEmptyComponentForLastEntity<Light>();
        l->lightType = LightType::Directional;
        l->intensity = 3.0f;
        l->color = {1.0f, 0.8f, 0.35f};
}

objectModule.newEntity(4, "Camera");
{
    auto c = objectModule.newEmptyComponentForLastEntity<Camera>();
    ViewFrustum& frustum = c->getFrustumModifiable();
        frustum.farPlane = 2500.0f;
        frustum.nearPlane = 0.1f;
        frustum.fieldOfView = 80.0f;
        frustum.aspectRatio = (float)GetCore().windowWidth / (float)GetCore().windowHeight;
        c->getProjectionModeModifiable() = CameraProjection::Perspective;

    auto t = objectModule.newEmptyComponentForLastEntity<Transform>();
        t->getLocalPositionModifiable() = glm::vec3(0.0f, 0.0f, 0.0f);
        t->setParent(&sceneModule.rootNode);

    auto li = objectModule.newEmptyComponentForLastEntity<AudioListener>();
        li->getIsCurrentModifiable() = true;
        li->getGainModifiable() = 1.0f;
        li->getVelocityModifiable();
        li->getPositionModifiable();
        li->getAtModifiable();
        li->getUpModifiable();
}

{
    objectModule.newModel("Resources/Models/Kayak_low_poly.FBX");
    Entity* paddleIndirect = objectModule.newEntity(1, "PaddleIndirect");
    {
        auto t = objectModule.newEmptyComponentForLastEntity<Transform>();
            t->setParent(objectModule.getEntityPtrByName("Kayak_low_poly.FBX/Kayak")->getComponentPtr<Transform>());
            //(objectModule.getEntityPtrByName("Player")->getComponentPtr<Transform>());
            t->getLocalRotationModifiable() = eulerToQuaternion(glm::vec3(0.0f, 180.0f, 180.0f));
            t->getLocalPositionModifiable() = glm::vec3(0.0f, 0.25f, 1.0f);
    }

    Material* kayakMat = objectModule.newMaterial(unlitColor, "kayakMat", RenderType::Opaque);
    auto kayakPtr = objectModule.getEntityPtrByName("Kayak_low_poly.FBX/Kayak");
    kayakMat->setVec4("color", glm::vec4(0.152f, 0.866f, 0.772f, 1.0f));
    {
        auto mr = kayakPtr->getComponentPtr<MeshRenderer>();
            mr->material = kayakMat;

        auto t = kayakPtr->getComponentPtr<Transform>();
            t->getLocalRotationModifiable() = eulerToQuaternion(glm::vec3(-90.0f, 0.0f, 180.0f));
            t->getLocalPositionModifiable() = glm::vec3(0.0f, 0, 7.0f);
            t->getLocalScaleModifiable() = glm::vec3(1.0f, 1.0f, 1.0f);
            t->setParent(&sceneModule.rootNode);

        // KAYAK MAN
        auto kayakRigidbody = objectModule.newEmptyComponent<Rigidbody>();
            kayakRigidbody->drag = 0.2f;
            kayakRigidbody->angularDrag = 0.1f;
            kayakRigidbody->mass = 150.0f;
            kayakRigidbody->ignoreGravity = false;
            kayakPtr->addComponent(kayakRigidbody);

        auto kayakBoxCollider = objectModule.newEmptyComponent<BoxCollider>();
            kayakBoxCollider->halfSize = glm::vec3(0.39f, 1.65f, 0.15f);
            kayakPtr->addComponent(kayakBoxCollider);

        auto kayakHydroBody = objectModule.newEmptyComponent<HydroBody>();
            kayakPtr->addComponent(kayakHydroBody);


        Material* paddleMat = objectModule.newMaterial(unlitColor, "paddleMat", RenderType::Opaque);
        paddleMat->setVec4("color", glm::vec4(0.670f, 0.427f, 0.109f, 1.0f));
        auto paddlePtr = objectModule.getEntityPtrByName("Kayak_low_poly.FBX/Paddle");
        {
            auto mr = paddlePtr->getComponentPtr<MeshRenderer>();
                mr->material = paddleMat;

            auto t = paddlePtr->getComponentPtr<Transform>();
                t->setParent(paddleIndirect->getComponentPtr<Transform>());

            auto paddle = objectModule.newEmptyComponent<Paddle>();
                paddle->maxPos = glm::vec3(-0.45f, 0.9f, -1.75f);
                paddle->maxFrontRot = -34.5f;
                paddle->maxSideRot = 30.0f;
                paddlePtr->addComponent(paddle);

            // PADDLE MAN
            auto paddleHydroAccelerator = objectModule.newEmptyComponent<HydroAccelerator>();
                paddleHydroAccelerator->rigidbody = kayakRigidbody;
                paddlePtr->addComponent(paddleHydroAccelerator);

            auto paddleHydroBody = objectModule.newEmptyComponent<HydroBody>();
                paddlePtr->addComponent(paddleHydroBody);
        }

        auto tpCameraPtr = objectModule.newEmptyComponent<ThirdPersonCamera>();
            tpCameraPtr->player = kayakPtr->getComponentPtr<Transform>();
            //tpCameraPtr->playerRigidbody = kayakPtr->getComponentPtr<Rigidbody>();

        auto fpCameraPtr = objectModule.newEmptyComponent<FirstPersonCamera>();
            fpCameraPtr->player = kayakPtr->getComponentPtr<Transform>();

        auto cameraPtr = objectModule.getEntityPtrByName("Camera");
            cameraPtr->addComponent(tpCameraPtr);
            cameraPtr->addComponent(fpCameraPtr);
            cameraPtr->getComponentPtr<Camera>()->control = CameraControl::ThirdPerson;
    }
}

TerrainUtils::loadAllTerrainChunks();
TerrainUtils::createMaterialsForModels();
TerrainUtils::loadExportedUnityModels();
TerrainUtils::importColliders();

//Game UI
{
    // Assets
    auto uiShader = objectModule.newShader("UiStandard", "Resources/Shaders/UiStandard/UiStandard.vert", "Resources/Shaders/UiStandard/UiStandard.frag");
    auto textShader = objectModule.newShader("TextStandard", "Resources/Shaders/TextStandard/TextStandard.vert", "Resources/Shaders/TextStandard/TextStandard.frag");
    auto textMaterial = objectModule.newMaterial(textShader, "TextMaterial", RenderType::Transparent);
    textMaterial->setVec4("color", {0.0f, 0.0f, 0.0f, 1.0f});
    auto courier = objectModule.newFont("Resources/Fonts/CourierNew.ttf", 128, "CourierNew");
    auto uiFading = objectModule.newShader("UiFading", "Resources/Shaders/UiFading/UiFading.vert", "Resources/Shaders/UiFading/UiFading.frag");
    TextureCreateInfo info = {};
    info.format = GL_RGBA;
    info.generateMipmaps = false;
    info.magFilter = GL_LINEAR;
    info.minFilter = GL_LINEAR;
    info.wrapMode = GL_CLAMP_TO_EDGE;
    auto rect_shadeless = objectModule.newTexture("Resources/Sprites/rect_2_1_shadeless.png", info);

    // Detection rate
    {
        objectModule.newEntity(2, "Detection_Rate_Group");
        auto buttonsRoot = objectModule.newEmptyComponentForLastEntity<RectTransform>();
            buttonsRoot->getAnchorModifiable() = glm::vec2(0.0f, 0.0f);
            buttonsRoot->getLocalPositionModifiable() = {290.0f, 0.0f};
        objectModule.newEmptyComponentForLastEntity<UiSortingGroup>();
        uiModule.rootNodes.push_back(buttonsRoot);
        objectModule.newEntity(2, "Detection_Rate_Bg");
        {
            auto rt = objectModule.newEmptyComponentForLastEntity<RectTransform>();
                rt->getLocalPositionModifiable() = {0.0f, 35.0f};
                rt->getSizeModifiable() = {570, 60};
                rt->setParent(buttonsRoot);
            auto ui = objectModule.newEmptyComponentForLastEntity<UiRenderer>();
                auto mat = objectModule.newMaterial(uiShader, "Detection_Rate_Bg_Mat", RenderType::Transparent);
                mat->setTexture("sprite", rect_shadeless);
                mat->setVec4("color", {0.811f, 0.815f, 0.949f, 1.0f});
                ui->material = mat;
        }
        objectModule.newEntity(2, "Detection_Rate_text");
        {
            auto crt = objectModule.newEmptyComponentForLastEntity<RectTransform>();
                crt->getLocalPositionModifiable() = {-273.0f, 25.0f};
                crt->getSizeModifiable() = {0.3f, 0.3f};
                crt->setParent(buttonsRoot);
            auto cui = objectModule.newEmptyComponentForLastEntity<TextRenderer>();
                cui->material = textMaterial;
                cui->mesh.font = courier;
                cui->mesh.text = "Detection Rate";
        }
        objectModule.newEntity(3, "DetectionProgressBar");
        {
            auto rt = objectModule.newEmptyComponentForLastEntity<RectTransform>();
                rt->getLocalPositionModifiable() = {167.0f, 35.0f};
                rt->getSizeModifiable() = {200, 50};
                rt->setParent(buttonsRoot);
            auto ui = objectModule.newEmptyComponentForLastEntity<UiRenderer>();
                auto mat = objectModule.newMaterial(uiFading, "Progress", RenderType::Transparent);
                mat->setTexture("sprite", rect_shadeless);
                mat->setVec4("color", {0.886f, 0.070f, 0.070f, 1.0f});
                ui->material = mat;
            auto pb = objectModule.newEmptyComponentForLastEntity<ProgressBar>();
        }
    }
    
    // Health
    {
        objectModule.newEntity(2, "Health_Bar_Group");
        auto buttonsRoot = objectModule.newEmptyComponentForLastEntity<RectTransform>();
            buttonsRoot->getAnchorModifiable() = glm::vec2(1.0f, 0.0f);
            buttonsRoot->getLocalPositionModifiable() = {-290.0f, 0.0f};
        objectModule.newEmptyComponentForLastEntity<UiSortingGroup>();
        uiModule.rootNodes.push_back(buttonsRoot);
        objectModule.newEntity(2, "Health_Bar_Bg");
        {
            auto rt = objectModule.newEmptyComponentForLastEntity<RectTransform>();
                rt->getLocalPositionModifiable() = {0.0f, 35.0f};
                rt->getSizeModifiable() = {570, 60};
                rt->setParent(buttonsRoot);
            auto ui = objectModule.newEmptyComponentForLastEntity<UiRenderer>();
                auto mat = objectModule.newMaterial(uiShader, "Detection_Rate_Bg_Mat", RenderType::Transparent);
                mat->setTexture("sprite", rect_shadeless);
                mat->setVec4("color", {0.811f, 0.815f, 0.949f, 1.0f});
                ui->material = mat;
        }
        objectModule.newEntity(2, "Health_Bar_text");
        {
            auto crt = objectModule.newEmptyComponentForLastEntity<RectTransform>();
                crt->getLocalPositionModifiable() = {-273.0f, 25.0f};
                crt->getSizeModifiable() = {0.3f, 0.3f};
                crt->setParent(buttonsRoot);
            auto cui = objectModule.newEmptyComponentForLastEntity<TextRenderer>();
                cui->material = textMaterial;
                cui->mesh.font = courier;
                cui->mesh.text = "Health";
        }
        objectModule.newEntity(3, "Health_Bar");
        {
            auto rt = objectModule.newEmptyComponentForLastEntity<RectTransform>();
                rt->getLocalPositionModifiable() = {167.0f, 35.0f};
                rt->getSizeModifiable() = {200, 50};
                rt->setParent(buttonsRoot);
            auto ui = objectModule.newEmptyComponentForLastEntity<UiRenderer>();
                auto mat = objectModule.newMaterial(uiFading, "Progress2", RenderType::Transparent);
                mat->setTexture("sprite", rect_shadeless);
                mat->setVec4("color", {0.886f, 0.070f, 0.070f, 1.0f});
                ui->material = mat;
            auto pb = objectModule.newEmptyComponentForLastEntity<ProgressBar>();
        }
    }
}
