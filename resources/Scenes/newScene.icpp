
auto standardPbrShader = objectModule.newShader("standardPbr", "Resources/Shaders/StandardPBR/StandardPBR.vert", "Resources/Shaders/StandardPBR/StandardPBR.frag");
auto flowmapShader = objectModule.newShader("flowmapShader", "Resources/Shaders/FlowmapWater/FlowmapWater.vert", "Resources/Shaders/FlowmapWater/FlowmapWater.frag");
auto standardSkinned = objectModule.newShader("standardSkinned", "Resources/Shaders/StandardSkinned/StandardSkinned.vert", "Resources/Shaders/StandardSkinned/StandardSkinned.frag");
//auto standardSkinned = objectModule.newShader("standardSkinned", "Resources/Shaders/UnlitSkinned/UnlitSkinned.vert", "Resources/Shaders/UnlitSkinned/UnlitSkinned.frag");
auto unlitColor = objectModule.newShader("UnlitColor", "Resources/Shaders/UnlitColor/UnlitColor.vert", "Resources/Shaders/UnlitColor/UnlitColor.frag");

TextureCreateInfo texCreateInfo = {};
texCreateInfo.generateMipmaps = true;
texCreateInfo.magFilter = GL_LINEAR;
texCreateInfo.minFilter = GL_LINEAR_MIPMAP_LINEAR;
texCreateInfo.wrapMode = GL_REPEAT;

auto water1Diffuse = objectModule.newTexture("Resources/Textures/Unity/water_diffuse.png", texCreateInfo);
auto water1Normal = objectModule.newTexture("Resources/Textures/Unity/water_normal.png", texCreateInfo);
auto emptyOccRouMet = objectModule.newTexture("Resources/Textures/Unity/water_occroumet.png", texCreateInfo);
auto noise = objectModule.newTexture("Resources/Flowmaps/noiseTexture.png", texCreateInfo);
auto flowmap_0_0_0 = objectModule.newTexture("Resources/Flowmaps/Plane_(0.0, 0.0, 0.0).png", texCreateInfo);
auto flowmap_0_0_m1 = objectModule.newTexture("Resources/Flowmaps/Plane_(0.0, 0.0, -100.0).png", texCreateInfo);
auto flowmap_1_0_0 = objectModule.newTexture("Resources/Flowmaps/Plane_(100.0, 0.0, 0.0).png", texCreateInfo);
auto flowmap_1_0_1 = objectModule.newTexture("Resources/Flowmaps/Plane_(100.0, 0.0, 100.0).png", texCreateInfo);
auto flowmap_1_0_3 = objectModule.newTexture("Resources/Flowmaps/Plane_(100.0, 0.0, 300.0).png", texCreateInfo);
auto flowmap_2_0_1 = objectModule.newTexture("Resources/Flowmaps/Plane_(200.0, 0.0, 100.0).png", texCreateInfo);
auto flowmap_2_0_2 = objectModule.newTexture("Resources/Flowmaps/Plane_(200.0, 0.0, 200.0).png", texCreateInfo);
auto flowmap_2_0_3 = objectModule.newTexture("Resources/Flowmaps/Plane_(200.0, 0.0, 300.0).png", texCreateInfo);
auto flowmap_3_0_1 = objectModule.newTexture("Resources/Flowmaps/Plane_(300.0, 0.0, 100.0).png", texCreateInfo);
auto flowmap_3_0_2 = objectModule.newTexture("Resources/Flowmaps/Plane_(300.0, 0.0, 200.0).png", texCreateInfo);
auto flowmap_3_0_3 = objectModule.newTexture("Resources/Flowmaps/Plane_(300.0, 0.0, 300.0).png", texCreateInfo);

Material* waterMat_3_0_3 = objectModule.newMaterial(flowmapShader, "waterMat_3_0_3", RenderType::Transparent);
waterMat_3_0_3->setTexture("diffuse", water1Diffuse);
waterMat_3_0_3->setTexture("normal", water1Normal);
waterMat_3_0_3->setTexture("occRouMet", emptyOccRouMet);
waterMat_3_0_3->setTexture("flowMap", flowmap_3_0_3);
waterMat_3_0_3->setVec2("channelFlowDirection", {-1.0f, 1.0f});
waterMat_3_0_3->setFloat("blendCycle", 1.0f);
waterMat_3_0_3->setFloat("cycleSpeed", 1.0f);
waterMat_3_0_3->setFloat("flowSpeed", 0.5f);
waterMat_3_0_3->setTexture("flowMapNoise", noise);
waterMat_3_0_3->setVec2("flowNoiseSize", {1.0f, 1.0f});
waterMat_3_0_3->setFloat("flowNoiseInfluence", 0.5f);
waterMat_3_0_3->setVec2("uvScale", {1.0f, 1.0f});

Material* waterMat_3_0_2 = objectModule.newMaterial(flowmapShader, "waterMat_3_0_2", RenderType::Transparent);
waterMat_3_0_2->setTexture("diffuse", water1Diffuse);
waterMat_3_0_2->setTexture("normal", water1Normal);
waterMat_3_0_2->setTexture("occRouMet", emptyOccRouMet);
waterMat_3_0_2->setTexture("flowMap", flowmap_3_0_2);
waterMat_3_0_2->setVec2("channelFlowDirection", {-1.0f, 1.0f});
waterMat_3_0_2->setFloat("blendCycle", 1.0f);
waterMat_3_0_2->setFloat("cycleSpeed", 1.0f);
waterMat_3_0_2->setFloat("flowSpeed", 0.5f);
waterMat_3_0_2->setTexture("flowMapNoise", noise);
waterMat_3_0_2->setVec2("flowNoiseSize", {1.0f, 1.0f});
waterMat_3_0_2->setFloat("flowNoiseInfluence", 0.5f);
waterMat_3_0_2->setVec2("uvScale", {1.0f, 1.0f});

Material* waterMat_3_0_1 = objectModule.newMaterial(flowmapShader, "waterMat_3_0_1", RenderType::Transparent);
waterMat_3_0_1->setTexture("diffuse", water1Diffuse);
waterMat_3_0_1->setTexture("normal", water1Normal);
waterMat_3_0_1->setTexture("occRouMet", emptyOccRouMet);
waterMat_3_0_1->setTexture("flowMap", flowmap_3_0_1);
waterMat_3_0_1->setVec2("channelFlowDirection", {-1.0f, 1.0f});
waterMat_3_0_1->setFloat("blendCycle", 1.0f);
waterMat_3_0_1->setFloat("cycleSpeed", 1.0f);
waterMat_3_0_1->setFloat("flowSpeed", 0.5f);
waterMat_3_0_1->setTexture("flowMapNoise", noise);
waterMat_3_0_1->setVec2("flowNoiseSize", {1.0f, 1.0f});
waterMat_3_0_1->setFloat("flowNoiseInfluence", 0.5f);
waterMat_3_0_1->setVec2("uvScale", {1.0f, 1.0f});

Material* waterMat_2_0_3 = objectModule.newMaterial(flowmapShader, "waterMat_2_0_3", RenderType::Transparent);
waterMat_2_0_3->setTexture("diffuse", water1Diffuse);
waterMat_2_0_3->setTexture("normal", water1Normal);
waterMat_2_0_3->setTexture("occRouMet", emptyOccRouMet);
waterMat_2_0_3->setTexture("flowMap", flowmap_2_0_3);
waterMat_2_0_3->setVec2("channelFlowDirection", {-1.0f, 1.0f});
waterMat_2_0_3->setFloat("blendCycle", 1.0f);
waterMat_2_0_3->setFloat("cycleSpeed", 1.0f);
waterMat_2_0_3->setFloat("flowSpeed", 0.5f);
waterMat_2_0_3->setTexture("flowMapNoise", noise);
waterMat_2_0_3->setVec2("flowNoiseSize", {1.0f, 1.0f});
waterMat_2_0_3->setFloat("flowNoiseInfluence", 0.5f);
waterMat_2_0_3->setVec2("uvScale", {1.0f, 1.0f});

Material* waterMat_2_0_2 = objectModule.newMaterial(flowmapShader, "waterMat_2_0_2", RenderType::Transparent);
waterMat_2_0_2->setTexture("diffuse", water1Diffuse);
waterMat_2_0_2->setTexture("normal", water1Normal);
waterMat_2_0_2->setTexture("occRouMet", emptyOccRouMet);
waterMat_2_0_2->setTexture("flowMap", flowmap_2_0_2);
waterMat_2_0_2->setVec2("channelFlowDirection", {-1.0f, 1.0f});
waterMat_2_0_2->setFloat("blendCycle", 1.0f);
waterMat_2_0_2->setFloat("cycleSpeed", 1.0f);
waterMat_2_0_2->setFloat("flowSpeed", 0.5f);
waterMat_2_0_2->setTexture("flowMapNoise", noise);
waterMat_2_0_2->setVec2("flowNoiseSize", {1.0f, 1.0f});
waterMat_2_0_2->setFloat("flowNoiseInfluence", 0.5f);
waterMat_2_0_2->setVec2("uvScale", {1.0f, 1.0f});

Material* waterMat_2_0_1 = objectModule.newMaterial(flowmapShader, "waterMat_2_0_1", RenderType::Transparent);
waterMat_2_0_1->setTexture("diffuse", water1Diffuse);
waterMat_2_0_1->setTexture("normal", water1Normal);
waterMat_2_0_1->setTexture("occRouMet", emptyOccRouMet);
waterMat_2_0_1->setTexture("flowMap", flowmap_2_0_1);
waterMat_2_0_1->setVec2("channelFlowDirection", {-1.0f, 1.0f});
waterMat_2_0_1->setFloat("blendCycle", 1.0f);
waterMat_2_0_1->setFloat("cycleSpeed", 1.0f);
waterMat_2_0_1->setFloat("flowSpeed", 0.5f);
waterMat_2_0_1->setTexture("flowMapNoise", noise);
waterMat_2_0_1->setVec2("flowNoiseSize", {1.0f, 1.0f});
waterMat_2_0_1->setFloat("flowNoiseInfluence", 0.5f);
waterMat_2_0_1->setVec2("uvScale", {1.0f, 1.0f});

Material* waterMat_1_0_3 = objectModule.newMaterial(flowmapShader, "waterMat_1_0_3", RenderType::Transparent);
waterMat_1_0_3->setTexture("diffuse", water1Diffuse);
waterMat_1_0_3->setTexture("normal", water1Normal);
waterMat_1_0_3->setTexture("occRouMet", emptyOccRouMet);
waterMat_1_0_3->setTexture("flowMap", flowmap_1_0_3);
waterMat_1_0_3->setVec2("channelFlowDirection", {-1.0f, 1.0f});
waterMat_1_0_3->setFloat("blendCycle", 1.0f);
waterMat_1_0_3->setFloat("cycleSpeed", 1.0f);
waterMat_1_0_3->setFloat("flowSpeed", 0.5f);
waterMat_1_0_3->setTexture("flowMapNoise", noise);
waterMat_1_0_3->setVec2("flowNoiseSize", {1.0f, 1.0f});
waterMat_1_0_3->setFloat("flowNoiseInfluence", 0.5f);
waterMat_1_0_3->setVec2("uvScale", {1.0f, 1.0f});

Material* waterMat_1_0_1 = objectModule.newMaterial(flowmapShader, "waterMat_1_0_1", RenderType::Transparent);
waterMat_1_0_1->setTexture("diffuse", water1Diffuse);
waterMat_1_0_1->setTexture("normal", water1Normal);
waterMat_1_0_1->setTexture("occRouMet", emptyOccRouMet);
waterMat_1_0_1->setTexture("flowMap", flowmap_1_0_1);
waterMat_1_0_1->setVec2("channelFlowDirection", {-1.0f, 1.0f});
waterMat_1_0_1->setFloat("blendCycle", 1.0f);
waterMat_1_0_1->setFloat("cycleSpeed", 1.0f);
waterMat_1_0_1->setFloat("flowSpeed", 0.5f);
waterMat_1_0_1->setTexture("flowMapNoise", noise);
waterMat_1_0_1->setVec2("flowNoiseSize", {1.0f, 1.0f});
waterMat_1_0_1->setFloat("flowNoiseInfluence", 0.5f);
waterMat_1_0_1->setVec2("uvScale", {1.0f, 1.0f});

Material* waterMat_1_0_0 = objectModule.newMaterial(flowmapShader, "waterMat_1_0_0", RenderType::Transparent);
waterMat_1_0_0->setTexture("diffuse", water1Diffuse);
waterMat_1_0_0->setTexture("normal", water1Normal);
waterMat_1_0_0->setTexture("occRouMet", emptyOccRouMet);
waterMat_1_0_0->setTexture("flowMap", flowmap_1_0_0);
waterMat_1_0_0->setVec2("channelFlowDirection", {-1.0f, 1.0f});
waterMat_1_0_0->setFloat("blendCycle", 1.0f);
waterMat_1_0_0->setFloat("cycleSpeed", 1.0f);
waterMat_1_0_0->setFloat("flowSpeed", 0.5f);
waterMat_1_0_0->setTexture("flowMapNoise", noise);
waterMat_1_0_0->setVec2("flowNoiseSize", {1.0f, 1.0f});
waterMat_1_0_0->setFloat("flowNoiseInfluence", 0.5f);
waterMat_1_0_0->setVec2("uvScale", {1.0f, 1.0f});

Material* waterMat_0_0_m1 = objectModule.newMaterial(flowmapShader, "waterMat_0_0_m1", RenderType::Transparent);
waterMat_0_0_m1->setTexture("diffuse", water1Diffuse);
waterMat_0_0_m1->setTexture("normal", water1Normal);
waterMat_0_0_m1->setTexture("occRouMet", emptyOccRouMet);
waterMat_0_0_m1->setTexture("flowMap", flowmap_0_0_m1);
waterMat_0_0_m1->setVec2("channelFlowDirection", {-1.0f, 1.0f});
waterMat_0_0_m1->setFloat("blendCycle", 1.0f);
waterMat_0_0_m1->setFloat("cycleSpeed", 1.0f);
waterMat_0_0_m1->setFloat("flowSpeed", 0.5f);
waterMat_0_0_m1->setTexture("flowMapNoise", noise);
waterMat_0_0_m1->setVec2("flowNoiseSize", {1.0f, 1.0f});
waterMat_0_0_m1->setFloat("flowNoiseInfluence", 0.5f);
waterMat_0_0_m1->setVec2("uvScale", {1.0f, 1.0f});

Material* waterMat_0_0_0 = objectModule.newMaterial(flowmapShader, "waterMat_0_0_0", RenderType::Transparent);
waterMat_0_0_0->setTexture("diffuse", water1Diffuse);
waterMat_0_0_0->setTexture("normal", water1Normal);
waterMat_0_0_0->setTexture("occRouMet", emptyOccRouMet);
waterMat_0_0_0->setTexture("flowMap", flowmap_0_0_0);
waterMat_0_0_0->setVec2("channelFlowDirection", {-1.0f, 1.0f});
waterMat_0_0_0->setFloat("blendCycle", 1.0f);
waterMat_0_0_0->setFloat("cycleSpeed", 1.0f);
waterMat_0_0_0->setFloat("flowSpeed", 0.5f);
waterMat_0_0_0->setTexture("flowMapNoise", noise);
waterMat_0_0_0->setVec2("flowNoiseSize", {1.0f, 1.0f});
waterMat_0_0_0->setFloat("flowNoiseInfluence", 0.5f);
waterMat_0_0_0->setVec2("uvScale", {1.0f, 1.0f});

objectModule.newEntity(1, "WaterPlanesRoot");
auto waterRoot = objectModule.newEmptyComponentForLastEntity<Transform>();
    waterRoot->getLocalPositionModifiable() = {50.0f, 0.0f, -50.0f};
    waterRoot->setParent(&sceneModule.rootNode);


objectModule.newModel("Resources/Models/Plane.obj");
{
    Entity* waterPlane0 = objectModule.getEntityPtrByName("Plane.obj/Plane");
    auto mr = waterPlane0->getComponentPtr<MeshRenderer>();
        mr->material = waterMat_0_0_0;

    auto t = waterPlane0->getComponentPtr<Transform>();
        t->getLocalPositionModifiable() = {0.0f, 0.0f, 0.0f};
        t->setParent(waterRoot);
}

objectModule.newEntity(2, "WaterPlane_0_0_m1");
{
    auto t = objectModule.newEmptyComponentForLastEntity<Transform>();
        t->getLocalPositionModifiable() = {0.0f, 0.0f, -100.0f};
        t->setParent(waterRoot);

    auto mr = objectModule.newEmptyComponentForLastEntity<MeshRenderer>();
        mr->material = waterMat_0_0_m1;
        mr->mesh = objectModule.getMeshCustomPtrByPath("Resources/Models/Plane.obj/Plane");
}

objectModule.newEntity(2, "WaterPlane_1_0_0");
{
    auto t = objectModule.newEmptyComponentForLastEntity<Transform>();
        t->getLocalPositionModifiable() = {-100.0f, 0.0f, 0.0f};
        t->setParent(waterRoot);

    auto mr = objectModule.newEmptyComponentForLastEntity<MeshRenderer>();
        mr->material = waterMat_1_0_0;
        mr->mesh = objectModule.getMeshCustomPtrByPath("Resources/Models/Plane.obj/Plane");
}

objectModule.newEntity(2, "WaterPlane_1_0_1");
{
    auto t = objectModule.newEmptyComponentForLastEntity<Transform>();
        t->getLocalPositionModifiable() = {-100.0f, 0.0f, 100.0f};
        t->setParent(waterRoot);

    auto mr = objectModule.newEmptyComponentForLastEntity<MeshRenderer>();
        mr->material = waterMat_1_0_1;
        mr->mesh = objectModule.getMeshCustomPtrByPath("Resources/Models/Plane.obj/Plane");
}

objectModule.newEntity(2, "WaterPlane_1_0_3");
{
    auto t = objectModule.newEmptyComponentForLastEntity<Transform>();
        t->getLocalPositionModifiable() = {-100.0f, 0.0f, 300.0f};
        t->setParent(waterRoot);

    auto mr = objectModule.newEmptyComponentForLastEntity<MeshRenderer>();
        mr->material = waterMat_1_0_3;
        mr->mesh = objectModule.getMeshCustomPtrByPath("Resources/Models/Plane.obj/Plane");
}

objectModule.newEntity(2, "WaterPlane_1_0_3");
{
    auto t = objectModule.newEmptyComponentForLastEntity<Transform>();
        t->getLocalPositionModifiable() = {-100.0f, 0.0f, 300.0f};
        t->setParent(waterRoot);

    auto mr = objectModule.newEmptyComponentForLastEntity<MeshRenderer>();
        mr->material = waterMat_1_0_3;
        mr->mesh = objectModule.getMeshCustomPtrByPath("Resources/Models/Plane.obj/Plane");
}

objectModule.newEntity(2, "WaterPlane_2_0_1");
{
    auto t = objectModule.newEmptyComponentForLastEntity<Transform>();
        t->getLocalPositionModifiable() = {-200.0f, 0.0f, 100.0f};
        t->setParent(waterRoot);

    auto mr = objectModule.newEmptyComponentForLastEntity<MeshRenderer>();
        mr->material = waterMat_2_0_1;
        mr->mesh = objectModule.getMeshCustomPtrByPath("Resources/Models/Plane.obj/Plane");
}

objectModule.newEntity(2, "WaterPlane_2_0_2");
{
    auto t = objectModule.newEmptyComponentForLastEntity<Transform>();
        t->getLocalPositionModifiable() = {-200.0f, 0.0f, 200.0f};
        t->setParent(waterRoot);

    auto mr = objectModule.newEmptyComponentForLastEntity<MeshRenderer>();
        mr->material = waterMat_2_0_2;
        mr->mesh = objectModule.getMeshCustomPtrByPath("Resources/Models/Plane.obj/Plane");
}

objectModule.newEntity(2, "WaterPlane_2_0_3");
{
    auto t = objectModule.newEmptyComponentForLastEntity<Transform>();
        t->getLocalPositionModifiable() = {-200.0f, 0.0f, 300.0f};
        t->setParent(waterRoot);

    auto mr = objectModule.newEmptyComponentForLastEntity<MeshRenderer>();
        mr->material = waterMat_2_0_3;
        mr->mesh = objectModule.getMeshCustomPtrByPath("Resources/Models/Plane.obj/Plane");
}

objectModule.newEntity(2, "WaterPlane_3_0_1");
{
    auto t = objectModule.newEmptyComponentForLastEntity<Transform>();
        t->getLocalPositionModifiable() = {-300.0f, 0.0f, 100.0f};
        t->setParent(waterRoot);

    auto mr = objectModule.newEmptyComponentForLastEntity<MeshRenderer>();
        mr->material = waterMat_3_0_1;
        mr->mesh = objectModule.getMeshCustomPtrByPath("Resources/Models/Plane.obj/Plane");
}

objectModule.newEntity(2, "WaterPlane_3_0_2");
{
    auto t = objectModule.newEmptyComponentForLastEntity<Transform>();
        t->getLocalPositionModifiable() = {-300.0f, 0.0f, 200.0f};
        t->setParent(waterRoot);

    auto mr = objectModule.newEmptyComponentForLastEntity<MeshRenderer>();
        mr->material = waterMat_3_0_2;
        mr->mesh = objectModule.getMeshCustomPtrByPath("Resources/Models/Plane.obj/Plane");
}

objectModule.newEntity(2, "WaterPlane_3_0_3");
{
    auto t = objectModule.newEmptyComponentForLastEntity<Transform>();
        t->getLocalPositionModifiable() = {-300.0f, 0.0f, 300.0f};
        t->setParent(waterRoot);

    auto mr = objectModule.newEmptyComponentForLastEntity<MeshRenderer>();
        mr->material = waterMat_3_0_3;
        mr->mesh = objectModule.getMeshCustomPtrByPath("Resources/Models/Plane.obj/Plane");
}

Material* hdrSkyboxMat = objectModule.newMaterial(skyboxShader, "skyboxHdrMat", RenderType::Opaque);
hdrSkyboxMat->setTexture("cubemap", hdrCubemap);
rendererModule.setSkybox(hdrSkyboxMat);

objectModule.newEntity(2, "directionalLight");
{
    auto t = objectModule.newEmptyComponentForLastEntity<Transform>();
        t->getLocalRotationModifiable() *= glm::angleAxis(glm::radians(150.0f) , glm::vec3(0.0f, 1.0f, 0.0f));
        t->getLocalRotationModifiable() *= glm::angleAxis(glm::radians(21.5f) , glm::vec3(1.0f, 0.0f, 0.0f));
        t->setParent(&sceneModule.rootNode);

    auto l = objectModule.newEmptyComponentForLastEntity<Light>();
        l->lightType = LightType::Directional;
        l->intensity = 3.0f;
        l->color = {1.0f, 0.8f, 0.35f};
}

objectModule.newEntity(4, "Camera");
{
    auto c = objectModule.newEmptyComponentForLastEntity<Camera>();
    ViewFrustum& frustum = c->getFrustumModifiable();
        frustum.farPlane = 2500.0f;
        frustum.nearPlane = 0.1f;
        frustum.fieldOfView = 80.0f;
        frustum.aspectRatio = (float)GetCore().windowWidth / (float)GetCore().windowHeight;
        c->getProjectionModeModifiable() = CameraProjection::Perspective;
        c->exposure = 1.5f;

    auto t = objectModule.newEmptyComponentForLastEntity<Transform>();
        t->getLocalPositionModifiable() = glm::vec3(0.0f, 0.0f, 0.0f);
        t->setParent(&sceneModule.rootNode);

    auto li = objectModule.newEmptyComponentForLastEntity<AudioListener>();
        li->getGainModifiable() = 1.0f;
        li->getVelocityModifiable();
        li->getPositionModifiable();
        li->getAtModifiable();
        li->getUpModifiable();
}

// objectModule.newEntity(2, "TestAudioSource1");
// {
//     auto t = objectModule.newEmptyComponentForLastEntity<Transform>();
//         t->getLocalPositionModifiable() = glm::vec3(5.0f, 0.0f, 0.0f);
//         t->setParent(&sceneModule.rootNode);

//     auto soMusic = objectModule.newEmptyComponentForLastEntity<AudioSource>();
//         soMusic->audioClip = "Resources/Audios/test.wav";
//         soMusic->getIsRelativeModifiable() = true;
//         soMusic->getGainModifiable() = 1.0f;
//         soMusic->getIsLoopingModifiable() = true;
//         soMusic->autoPlay = true;
// }

// objectModule.newEntity(2, "TestAudioSource2");
// {
//     auto t = objectModule.newEmptyComponentForLastEntity<Transform>();
//         t->getLocalPositionModifiable() = glm::vec3(-5.0f, 0.0f, 0.0f);
//         t->setParent(&sceneModule.rootNode);

//     auto soMusic = objectModule.newEmptyComponentForLastEntity<AudioSource>();
//         soMusic->audioClip = "Resources/Audios/test.wav";
//         soMusic->getIsRelativeModifiable() = true;
//         soMusic->getGainModifiable() = 1.0f;
//         soMusic->getIsLoopingModifiable() = true;
//         soMusic->autoPlay = true;
// }

{
    objectModule.newModel("Resources/Models/Kayak_final/Final_physics_meshes.FBX");

    Entity* attachLeft = objectModule.getEntityPtrByName("Final_physics_meshes.FBX/Paddle_attach_left");
    Entity* attachRight = objectModule.getEntityPtrByName("Final_physics_meshes.FBX/Paddle_attach_right");
    {
        auto tl = attachLeft->getComponentPtr<Transform>();
            tl->getLocalPositionModifiable() = {tl->getLocalPosition().x, 0.08f, tl->getLocalPosition().z};
        auto tr = attachRight->getComponentPtr<Transform>();
            tr->getLocalPositionModifiable() = {tr->getLocalPosition().x, 0.08f, tr->getLocalPosition().z};

        auto mrl = attachLeft->getComponentPtr<MeshRenderer>();
            mrl->shouldRender = false;
        auto mrr = attachRight->getComponentPtr<MeshRenderer>();
            mrr->shouldRender = false;
    }

    Entity* paddleIndirect = objectModule.newEntity(1, "PaddleIndirect");
    {
        auto t = objectModule.newEmptyComponentForLastEntity<Transform>();
            t->setParent(objectModule.getEntityPtrByName("Final_physics_meshes.FBX/Physics_kayak")->getComponentPtr<Transform>());
            t->getLocalRotationModifiable() = eulerToQuaternion(glm::vec3(0.0f, 0.0f, 180.0f));
            t->getLocalPositionModifiable() = glm::vec3(0.0f, -0.1f, 0.3f);
    }

    Material* kayakMat = objectModule.newMaterial(unlitColor, "kayakMat", RenderType::Opaque);
    auto kayakPtr = objectModule.getEntityPtrByName("Final_physics_meshes.FBX/Physics_kayak");
    Transform* kayakTransform = nullptr;
    Transform* paddleTransform = nullptr;
    kayakMat->setVec4("color", glm::vec4(0.152f, 0.866f, 0.772f, 1.0f));
    {
        auto mr = kayakPtr->getComponentPtr<MeshRenderer>();
            //mr->material = kayakMat;
            mr->shouldRender = false;

        kayakTransform = kayakPtr->getComponentPtr<Transform>();
            kayakTransform->getLocalRotationModifiable() = eulerToQuaternion(glm::vec3(90.0f, 70.0f, -180.0f));
            kayakTransform->getLocalPositionModifiable() = glm::vec3(31.0f, 0.0f, -1.0f);
            kayakTransform->getLocalScaleModifiable() = glm::vec3(1.0f, 1.0f, 1.0f);
            kayakTransform->setParent(&sceneModule.rootNode);

        // KAYAK MAN
        auto kayakRigidbody = objectModule.newEmptyComponent<Rigidbody>();
            kayakRigidbody->drag = 0.1f;
            kayakRigidbody->angularDrag = 0.35f;
            kayakRigidbody->mass = 120.0f;
            kayakRigidbody->ignoreGravity = false;
            kayakPtr->addComponent(kayakRigidbody);

        auto kayakBoxCollider = objectModule.newEmptyComponent<BoxCollider>();
            kayakBoxCollider->halfSize = glm::vec3(0.39f, 1.65f, 0.15f);
            kayakPtr->addComponent(kayakBoxCollider);

        auto kayakHydroBody = objectModule.newEmptyComponent<HydroBody>();
            kayakPtr->addComponent(kayakHydroBody);
            
        auto* kayakComponent = objectModule.newEmptyComponent<Kayak>();
            kayakPtr->addComponent(kayakComponent);
        
        auto* storage = objectModule.newEmptyComponent<CargoStorage>();
            kayakPtr->addComponent(storage);
        Core::cargoStorageSystem.init(storage);

        Material* paddleMat = objectModule.newMaterial(unlitColor, "paddleMat", RenderType::Opaque);
        paddleMat->setVec4("color", glm::vec4(0.670f, 0.427f, 0.109f, 1.0f));
        auto paddlePtr = objectModule.getEntityPtrByName("Final_physics_meshes.FBX/Physics_paddle");
        {
            auto mr = paddlePtr->getComponentPtr<MeshRenderer>();
                //mr->material = paddleMat;
                mr->shouldRender = false;

            paddleTransform = paddlePtr->getComponentPtr<Transform>();
                paddleTransform->setParent(paddleIndirect->getComponentPtr<Transform>());

            auto paddle = objectModule.newEmptyComponent<Paddle>();
                paddle->maxPos = glm::vec3(0.0f, 0.0f, -0.15f);
                paddle->maxFrontRot = 45.0f;
                paddle->maxSideRot = 25.0f;
                paddlePtr->addComponent(paddle);

            // PADDLE MAN
            auto paddleHydroAccelerator = objectModule.newEmptyComponent<HydroAccelerator>();
                paddleHydroAccelerator->rigidbody = kayakRigidbody;
                paddleHydroAccelerator->handling = 80;
                paddleHydroAccelerator->acceleration = 0.5f;
                paddlePtr->addComponent(paddleHydroAccelerator);

            auto paddleHydroBody = objectModule.newEmptyComponent<HydroBody>();
                paddlePtr->addComponent(paddleHydroBody);
        }

        auto tpCameraPtr = objectModule.newEmptyComponent<ThirdPersonCamera>();
            tpCameraPtr->player = kayakPtr->getComponentPtr<Transform>();
            // tpCameraPtr->minDistance = 2.0f;
            // tpCameraPtr->maxDistance = 8.0f;
            //tpCameraPtr->playerRigidbody = kayakPtr->getComponentPtr<Rigidbody>();

        auto fpCameraPtr = objectModule.newEmptyComponent<FirstPersonCamera>();
            fpCameraPtr->player = kayakPtr->getComponentPtr<Transform>();
            // fpCameraPtr->headOffset.y = 0.7f;

        auto cameraPtr = objectModule.getEntityPtrByName("Camera");
            cameraPtr->addComponent(tpCameraPtr);
            cameraPtr->addComponent(fpCameraPtr);
            cameraPtr->getComponentPtr<Camera>()->control = CameraControl::ThirdPerson;
    }

    // ! NJU KAJAK
    {
        // * MATERIALS
        auto kayakDiffuse = objectModule.newTexture("Resources/Models/Kayak_final/Kayak_and_paddle_textured_albedo.tga", texCreateInfo);
        auto kayakNormal = objectModule.newTexture("Resources/Models/Kayak_final/Kayak_and_paddle_textured_normal.tga", texCreateInfo);
        auto kayakOccRouMet = objectModule.newTexture("Resources/Models/Kayak_final/Kayak_and_paddle_textured_occRouMet.tga", texCreateInfo);

        Material* kayakTextured = objectModule.newMaterial(standardPbrShader, "kayakTextured", RenderType::Opaque);
        kayakTextured->setTexture("diffuse", kayakDiffuse);
        kayakTextured->setTexture("normal", kayakNormal);
        kayakTextured->setTexture("occRouMet", kayakOccRouMet);

        objectModule.newModel("Resources/Models/Kayak_final/Final_kayak_and_paddle.FBX");
        Entity* testKayak = objectModule.getEntityPtrByName("Final_kayak_and_paddle.FBX/Kayak_fixed_collapsed");
        {
            auto mr = testKayak->getComponentPtr<MeshRenderer>();
                mr->material = kayakTextured;

            auto t = testKayak->getComponentPtr<Transform>();
                t->setParent(kayakTransform);
        }

        Entity* testPaddle = objectModule.getEntityPtrByName("Final_kayak_and_paddle.FBX/Paddle_collapsed");
        {
            auto mr = testPaddle->getComponentPtr<MeshRenderer>();
                mr->material = kayakTextured;

            auto t = testPaddle->getComponentPtr<Transform>();
                t->setParent(paddleTransform);
        }
    }

    // ! NJU POSTAC
    {
        objectModule.newModel("Resources/Models/Character_final/Final_character_rigged.FBX");

        Entity* hips = objectModule.getEntityPtrByName("Final_character_rigged.FBX/mixamorig:Hips(bone)");
        {
            auto t = hips->getComponentPtr<Transform>();
                t->getLocalScaleModifiable() = {0.01f, 0.01f, 0.01f};
                t->getLocalRotationModifiable() = eulerToQuaternion({90.0f, 0.0f, 180.0f});
                t->getLocalPositionModifiable() = {0.0f, -0.45f, 0.0f};
                t->setParent(kayakTransform);
        }

        auto bodyAlbedo = objectModule.newTexture("Resources/Models/Character_final/Kajakarz_Body_BaseColor.png", texCreateInfo);
        auto bodyNormal = objectModule.newTexture("Resources/Models/Character_final/Kajakarz_Body_Normal.png", texCreateInfo);
        auto bodyOccRouMet = objectModule.newTexture("Resources/Models/Character_final/Kajakarz_Body_OccRouMet.png", texCreateInfo);

        Material* bodyMat = objectModule.newMaterial(standardSkinned, "bodyMat", RenderType::Opaque);
        bodyMat->setTexture("diffuse", bodyAlbedo);
        bodyMat->setTexture("normal", bodyNormal);
        bodyMat->setTexture("occRouMet", bodyOccRouMet);

        Entity* body = objectModule.getEntityPtrByName("Final_character_rigged.FBX/Body");
        {
            auto mr = body->getComponentPtr<MeshRenderer>();
                mr->material = bodyMat;
                mr->mesh->frustumCulling = false;
        }

        Entity* eyes = objectModule.getEntityPtrByName("Final_character_rigged.FBX/Eyes");
        {
            auto mr = eyes->getComponentPtr<MeshRenderer>();
                mr->material = bodyMat;
                mr->mesh->frustumCulling = false;
        }

        Material* eyelashesMat = objectModule.newMaterial(standardSkinned, "eyelashesMat", RenderType::Transparent);
        eyelashesMat->setTexture("diffuse", bodyAlbedo);
        eyelashesMat->setTexture("normal", bodyNormal);
        eyelashesMat->setTexture("occRouMet", bodyOccRouMet);

        Entity* eyelashes = objectModule.getEntityPtrByName("Final_character_rigged.FBX/Eyelashes");
        {
            auto mr = eyelashes->getComponentPtr<MeshRenderer>();
                mr->material = eyelashesMat;
                mr->mesh->frustumCulling = false;
        }

        auto gloveAlbedo = objectModule.newTexture("Resources/Models/Character_final/Kajakarz_Glove_BaseColor.png", texCreateInfo);
        auto gloveNormal = objectModule.newTexture("Resources/Models/Character_final/Kajakarz_Glove_Normal.png", texCreateInfo);
        auto gloveOccRouMet = objectModule.newTexture("Resources/Models/Character_final/Kajakarz_Glove_OccRouMet.png", texCreateInfo);

        Material* gloveMat = objectModule.newMaterial(standardSkinned, "gloveMat", RenderType::Opaque);
        gloveMat->setTexture("diffuse", gloveAlbedo);
        gloveMat->setTexture("normal", gloveNormal);
        gloveMat->setTexture("occRouMet", gloveOccRouMet);

        Entity* gloves = objectModule.getEntityPtrByName("Final_character_rigged.FBX/Gloves");
        {
            auto mr = gloves->getComponentPtr<MeshRenderer>();
                mr->material = gloveMat;
                mr->mesh->frustumCulling = false;
        }

        auto hatAlbedo = objectModule.newTexture("Resources/Models/Character_final/Kajakarz_Hat_BaseColor.png", texCreateInfo);
        auto hatNormal = objectModule.newTexture("Resources/Models/Character_final/Kajakarz_Hat_Normal.png", texCreateInfo);
        auto hatOccRouMet = objectModule.newTexture("Resources/Models/Character_final/Kajakarz_Hat_OccRouMet.png", texCreateInfo);

        Material* hatMat = objectModule.newMaterial(standardSkinned, "hatMat", RenderType::Opaque);
        hatMat->setTexture("diffuse", hatAlbedo);
        hatMat->setTexture("normal", hatNormal);
        hatMat->setTexture("occRouMet", hatOccRouMet);

        Entity* hats = objectModule.getEntityPtrByName("Final_character_rigged.FBX/Hats");
        {
            auto mr = hats->getComponentPtr<MeshRenderer>();
                mr->material = hatMat;
                mr->mesh->frustumCulling = false;
        }

        auto maskAlbedo = objectModule.newTexture("Resources/Models/Character_final/Kajakarz_Mask_BaseColor.png", texCreateInfo);
        auto maskNormal = objectModule.newTexture("Resources/Models/Character_final/Kajakarz_Mask_Normal.png", texCreateInfo);
        auto maskOccRouMet = objectModule.newTexture("Resources/Models/Character_final/Kajakarz_Mask_OccRouMet.png", texCreateInfo);

        Material* maskMat = objectModule.newMaterial(standardSkinned, "maskMat", RenderType::Opaque);
        maskMat->setTexture("diffuse", maskAlbedo);
        maskMat->setTexture("normal", maskNormal);
        maskMat->setTexture("occRouMet", maskOccRouMet);

        Entity* masks = objectModule.getEntityPtrByName("Final_character_rigged.FBX/Masks");
        {
            auto mr = masks->getComponentPtr<MeshRenderer>();
                mr->material = maskMat;
                mr->mesh->frustumCulling = false;
        }

        auto topAlbedo = objectModule.newTexture("Resources/Models/Character_final/Kajakarz_Top_BaseColor.png", texCreateInfo);
        auto topNormal = objectModule.newTexture("Resources/Models/Character_final/Kajakarz_Top_Normal.png", texCreateInfo);
        auto topOccRouMet = objectModule.newTexture("Resources/Models/Character_final/Kajakarz_Top_OccRouMet.png", texCreateInfo);

        Material* topMat = objectModule.newMaterial(standardSkinned, "topMat", RenderType::Opaque);
        topMat->setTexture("diffuse", topAlbedo);
        topMat->setTexture("normal", topNormal);
        topMat->setTexture("occRouMet", topOccRouMet);

        Entity* tops = objectModule.getEntityPtrByName("Final_character_rigged.FBX/Tops");
        {
            auto mr = tops->getComponentPtr<MeshRenderer>();
                mr->material = topMat;
                mr->mesh->frustumCulling = false;
        }

        // ! ----- IK -----
        {
            Entity* e = objectModule.getEntityPtrByName("Final_character_rigged.FBX/mixamorig:LeftArm(bone)");
            auto t = e->getComponentPtr<Transform>();
                t->getLocalRotationModifiable() = eulerToQuaternion({61, -36, 29});
            auto b = e->getComponentPtr<Bone>();
                b->minConstraints = {40.0f, -80.0f, 10.0f};
                b->maxConstraints = {60.0f, 30.0f, 30.0f};
        }
        {
            Entity* e = objectModule.getEntityPtrByName("Final_character_rigged.FBX/mixamorig:LeftForeArm(bone)");
            auto t = e->getComponentPtr<Transform>();
                t->getLocalRotationModifiable() = eulerToQuaternion({-25, 35, 55});
            auto b = e->getComponentPtr<Bone>();
                b->minConstraints = {-40.0f, 30.0f, 25.0f};
                b->maxConstraints = {-5.0f, 60.0f, 130.0f};
        }
        {
            Entity* e = objectModule.getEntityPtrByName("Final_character_rigged.FBX/mixamorig:LeftHand(bone)");
            auto t = e->getComponentPtr<Transform>();
                t->getLocalRotationModifiable() = eulerToQuaternion({-5, 26, 12});
        }
        {
            Entity* e = objectModule.getEntityPtrByName("Final_character_rigged.FBX/mixamorig:LeftHandIndex1(bone)");
            auto t = e->getComponentPtr<Transform>();
                t->getLocalRotationModifiable() = eulerToQuaternion({63, 0, 0});
        }
        {
            Entity* e = objectModule.getEntityPtrByName("Final_character_rigged.FBX/mixamorig:LeftHandIndex2(bone)");
            auto t = e->getComponentPtr<Transform>();
                t->getLocalRotationModifiable() = eulerToQuaternion({78, 0, 0});
        }
        {
            Entity* e = objectModule.getEntityPtrByName("Final_character_rigged.FBX/mixamorig:LeftHand(bone)");
            IKBonePoint* bp1 = objectModule.newEmptyComponent<IKBonePoint>();
            bp1->touchPoint = attachRight->getComponentPtr<Transform>();
            bp1->chainLength = 1;
            bp1->skeletonPtr = objectModule.getEntityPtrByName("mixamorig:Hips_skeleton")->getComponentPtr<Skeleton>();
            bp1->iterations = 2;
            bp1->delta = 0.001f;
            e->addComponent(bp1);
        }

        {
            Entity* e = objectModule.getEntityPtrByName("Final_character_rigged.FBX/mixamorig:RightArm(bone)");
            auto t = e->getComponentPtr<Transform>();
                t->getLocalRotationModifiable() = eulerToQuaternion({83, 47, 0});
            auto b = e->getComponentPtr<Bone>();
                b->minConstraints = {70.0f, -40.0f, -10.0f};
                b->maxConstraints = {80.0f, 80.0f, 40.0f};
        }
        {
            Entity* e = objectModule.getEntityPtrByName("Final_character_rigged.FBX/mixamorig:RightForeArm(bone)");
            auto t = e->getComponentPtr<Transform>();
                t->getLocalRotationModifiable() = eulerToQuaternion({0, -35, -75});
            auto b = e->getComponentPtr<Bone>();
                b->minConstraints = {-15.0f, -30.0f, -130.0f};
                b->maxConstraints = {15.0f, -10.0f, -27.0f};
        }
        {
            Entity* e = objectModule.getEntityPtrByName("Final_character_rigged.FBX/mixamorig:RightHand(bone)");
            auto t = e->getComponentPtr<Transform>();
                t->getLocalRotationModifiable() = eulerToQuaternion({0, -50, 0});
        }
        {
            Entity* e = objectModule.getEntityPtrByName("Final_character_rigged.FBX/mixamorig:RightHandIndex1(bone)");
            auto t = e->getComponentPtr<Transform>();
                t->getLocalRotationModifiable() = eulerToQuaternion({72, 0, 0});
        }
        {
            Entity* e = objectModule.getEntityPtrByName("Final_character_rigged.FBX/mixamorig:RightHandIndex2(bone)");
            auto t = e->getComponentPtr<Transform>();
                t->getLocalRotationModifiable() = eulerToQuaternion({72, 0, 0});
        }
        {
            Entity* e = objectModule.getEntityPtrByName("Final_character_rigged.FBX/mixamorig:RightHand(bone)");
            IKBonePoint* bp1 = objectModule.newEmptyComponent<IKBonePoint>();
            bp1->touchPoint = attachLeft->getComponentPtr<Transform>();
            bp1->chainLength = 1;
            bp1->skeletonPtr = objectModule.getEntityPtrByName("mixamorig:Hips_skeleton")->getComponentPtr<Skeleton>();
            bp1->iterations = 2;
            bp1->delta = 0.001f;
            e->addComponent(bp1);
        }

    }
}

if (GetCore().loadTerrain)
{
    TerrainUtils::loadAllTerrainChunks();
}
TerrainUtils::createMaterialsForModels();
TerrainUtils::loadExportedUnityModels();
TerrainUtils::importColliders();

//Game UI
{
    // Assets
    auto uiShader = objectModule.newShader("UiStandard", "Resources/Shaders/UiStandard/UiStandard.vert", "Resources/Shaders/UiStandard/UiStandard.frag");
    auto textShader = objectModule.newShader("TextStandard", "Resources/Shaders/TextStandard/TextStandard.vert", "Resources/Shaders/TextStandard/TextStandard.frag");
    auto textMaterial = objectModule.newMaterial(textShader, "TextMaterial", RenderType::Transparent);
    auto textMaterial2 = objectModule.newMaterial(textShader, "TextMaterial2", RenderType::Transparent);
    auto textMaterial3 = objectModule.newMaterial(textShader, "TextMaterial3", RenderType::Transparent);
    
    textMaterial->setVec4("color", {1.0f, 1.0f, 1.0f, 1.0f});
    textMaterial2->setVec4("color", {1.0f, 1.0f, 1.0f, 1.0f});
    textMaterial3->setVec4("color", {0.941f, 0.043f, 0.0f, 1.0f});
    auto courier = objectModule.newFont("Resources/Fonts/CourierNew.ttf", 128, "CourierNew");
    auto courier_bold = objectModule.newFont("Resources/Fonts/CourierNew-Bold.ttf", 128, "CourierNew-Bold");
    auto uiFading = objectModule.newShader("UiFading", "Resources/Shaders/UiFading/UiFading.vert", "Resources/Shaders/UiFading/UiFading.frag");
    TextureCreateInfo uiInfo = {};
    uiInfo.format = GL_RGBA;
    uiInfo.generateMipmaps = false;
    uiInfo.magFilter = GL_LINEAR;
    uiInfo.minFilter = GL_LINEAR;
    uiInfo.wrapMode = GL_CLAMP_TO_EDGE;
    auto capsule_1 = objectModule.newTexture("Resources/Sprites/capsule_241_17.png", uiInfo);
    auto capsule_border_1 = objectModule.newTexture("Resources/Sprites/capsule_border_250_25.png", uiInfo);
    auto capsule_2 = objectModule.newTexture("Resources/Sprites/capsule_370_23.png", uiInfo);
    auto capsule_border_2 = objectModule.newTexture("Resources/Sprites/capsule_border_380_30.png", uiInfo);

    // Detection rate
    {
        objectModule.newEntity(2, "Detection_Rate_Group");
        auto detectionGroup = objectModule.newEmptyComponentForLastEntity<RectTransform>();
        {
            detectionGroup->getAnchorModifiable() = glm::vec2(0.5f, 0.0f);
            detectionGroup->getLocalPositionModifiable() = {0.0f, 54.0f};
            uiModule.rootNodes.push_back(detectionGroup);
            auto group = objectModule.newEmptyComponentForLastEntity<UiSortingGroup>();
            group->groupTransparency = 0.0f;
        }
        objectModule.newEntity(2, "Detection_Rate_text");
        {
            auto crt = objectModule.newEmptyComponentForLastEntity<RectTransform>();
                crt->getLocalPositionModifiable() = {-68.0f, 57.0f};
                crt->getSizeModifiable() = {0.2f, 0.2f};
                crt->setParent(detectionGroup);
            auto cui = objectModule.newEmptyComponentForLastEntity<TextRenderer>();
                cui->material = textMaterial;
                cui->mesh.font = courier_bold;
                cui->mesh.text = "Detection";
        }
        objectModule.newEntity(3, "DetectionProgressBar");
        {
            auto rt = objectModule.newEmptyComponentForLastEntity<RectTransform>();
                rt->getLocalPositionModifiable() = {0.0f, 35.0f};
                rt->getSizeModifiable() = {241, 17};
                rt->setParent(detectionGroup);
            auto ui = objectModule.newEmptyComponentForLastEntity<UiRenderer>();
                auto mat = objectModule.newMaterial(uiFading, "Progress", RenderType::Transparent);
                mat->setTexture("sprite", capsule_1);
                mat->setVec4("color", {00.980f, 0.662f, 0.2f, 1.0f});
                ui->material = mat;
            auto pb = objectModule.newEmptyComponentForLastEntity<ProgressBar>();
        }
        objectModule.newEntity(2, "Detection_Rate_Border");
        {
            auto rt = objectModule.newEmptyComponentForLastEntity<RectTransform>();
                rt->getLocalPositionModifiable() = {0.0f, 35.0f};
                rt->getSizeModifiable() = {250, 25};
                rt->setParent(detectionGroup);
            auto ui = objectModule.newEmptyComponentForLastEntity<UiRenderer>();
                auto mat = objectModule.newMaterial(uiShader, "Border_Mat_1", RenderType::Transparent);
                mat->setTexture("sprite", capsule_border_1);
                mat->setVec4("color", {1.0f, 1.0f, 1.0f, 1.0f});
                ui->material = mat;
        }
    }
    
    // Health
    {
        objectModule.newEntity(2, "Health_Bar_Group");
        auto healthGroup = objectModule.newEmptyComponentForLastEntity<RectTransform>();
        {
            healthGroup->getAnchorModifiable() = glm::vec2(0.5f, 0.0f);
            healthGroup->getLocalPositionModifiable() = {0.0f, 0.0f};
            auto group = objectModule.newEmptyComponentForLastEntity<UiSortingGroup>();
            group->groupTransparency = 0.8f;
            uiModule.rootNodes.push_back(healthGroup);
        }
        objectModule.newEntity(2, "Health_Bar_text");
        {
            auto crt = objectModule.newEmptyComponentForLastEntity<RectTransform>();
                crt->getLocalPositionModifiable() = {-43.0f, 13.0f};
                crt->getSizeModifiable() = {0.2f, 0.2f};
                crt->setParent(healthGroup);
            auto cui = objectModule.newEmptyComponentForLastEntity<TextRenderer>();
                cui->material = textMaterial2;
                cui->mesh.font = courier_bold;
                cui->mesh.text = "Health";
        }
        objectModule.newEntity(3, "Health_Bar");
        {
            auto rt = objectModule.newEmptyComponentForLastEntity<RectTransform>();
                rt->getLocalPositionModifiable() = {0.0f, 50.0f};
                rt->getSizeModifiable() = {370, 23};
                rt->setParent(healthGroup);
            auto ui = objectModule.newEmptyComponentForLastEntity<UiRenderer>();
                auto mat = objectModule.newMaterial(uiFading, "Progress2", RenderType::Transparent);
                mat->setTexture("sprite", capsule_2);
                mat->setVec4("color", {0.886f, 0.070f, 0.070f, 1.0f});
                ui->material = mat;
            auto pb = objectModule.newEmptyComponentForLastEntity<ProgressBar>();
        }
        objectModule.newEntity(2, "Health_Bar_Border");
        {
            auto rt = objectModule.newEmptyComponentForLastEntity<RectTransform>();
                rt->getLocalPositionModifiable() = {0.0f, 50.0f};
                rt->getSizeModifiable() = {380, 30};
                rt->setParent(healthGroup);
            auto ui = objectModule.newEmptyComponentForLastEntity<UiRenderer>();
                auto mat = objectModule.newMaterial(uiShader, "Border_Mat_2", RenderType::Transparent);
                mat->setTexture("sprite", capsule_border_2);
                mat->setVec4("color", {1.0f, 1.0f, 1.0f, 1.0f});
                ui->material = mat;
        }
    }

    // LOST CARGO
    {
        objectModule.newEntity(3, "Cargo_Lost_Group");
        auto cargoLost = objectModule.newEmptyComponentForLastEntity<RectTransform>();
        {
            cargoLost->getAnchorModifiable() = glm::vec2(0.5f, 0.0f);
            cargoLost->getLocalPositionModifiable() = {-165.0f, 140.0f};
            cargoLost->getSizeModifiable() = {0.3f, 0.3f};
            auto group = objectModule.newEmptyComponentForLastEntity<UiSortingGroup>();
                group->disappearanceTime = 5.0f;
                group->disappearanceFactor = 0.1f;
                group->groupTransparency = 0.0f;
            uiModule.rootNodes.push_back(cargoLost);
            auto cui = objectModule.newEmptyComponentForLastEntity<TextRenderer>();
                cui->material = textMaterial3;
                cui->mesh.font = courier_bold;
                cui->mesh.text = "Cargo was Lost!";
        }
    }

    //TUTORIAL
    {
        auto basic = objectModule.newTexture("Resources/Sprites/tutorial/pad_basic.png", uiInfo);
        objectModule.newTexture("Resources/Sprites/tutorial/pad_down.png", uiInfo);
        objectModule.newTexture("Resources/Sprites/tutorial/pad_down_left.png", uiInfo);
        objectModule.newTexture("Resources/Sprites/tutorial/pad_down_right.png", uiInfo);
        objectModule.newTexture("Resources/Sprites/tutorial/pad_down.png", uiInfo);
        objectModule.newTexture("Resources/Sprites/tutorial/pad_left.png", uiInfo);
        objectModule.newTexture("Resources/Sprites/tutorial/pad_right.png", uiInfo);
        objectModule.newTexture("Resources/Sprites/tutorial/pad_up.png", uiInfo);
        objectModule.newTexture("Resources/Sprites/tutorial/pad_up_left.png", uiInfo);
        objectModule.newTexture("Resources/Sprites/tutorial/pad_up_right.png", uiInfo);
        objectModule.newTexture("Resources/Sprites/tutorial/arrow_down_up.png", uiInfo);
        objectModule.newTexture("Resources/Sprites/tutorial/arrow_left_down.png", uiInfo);
        objectModule.newTexture("Resources/Sprites/tutorial/arrow_right_down.png", uiInfo);
        objectModule.newTexture("Resources/Sprites/tutorial/arrow_up_left.png", uiInfo);
        objectModule.newTexture("Resources/Sprites/tutorial/arrow_up_right.png", uiInfo);

        auto tutBase = objectModule.newEntity(4, "Tutorial");
        {
            auto rt = objectModule.newEmptyComponentForLastEntity<RectTransform>();
                uiModule.rootNodes.push_back(rt);
                rt->getSizeModifiable() = {350, 275};
                rt->getAnchorModifiable() = {1.0f, 0.0f};
                rt->getLocalPositionModifiable() = {-180, 142.0f};
            
            auto tex = objectModule.newTexture("Resources/Sprites/tutorial/tutorial_bg.png", uiInfo);
            auto uir = objectModule.newEmptyComponentForLastEntity<UiRenderer>();
                uir->material = objectModule.newMaterial(objectModule.getShaderPtrByName("UiStandard"), "tutorialBg", RenderType::Transparent);
                uir->material->setVec4("color", {1.0f, 1.0f, 1.0f, 0.8f});
                uir->material->setTexture("sprite", tex);
            
            auto tut = objectModule.newEmptyComponentForLastEntity<Tutorial>();
            tut->timeOfBoard = 0.5f;

            auto group = objectModule.newEmptyComponentForLastEntity<UiSortingGroup>();
                group->groupTransparency = 0.7f;
        }

        objectModule.newEntity(2, "Tutorial_pad");
        {
            auto rt = objectModule.newEmptyComponentForLastEntity<RectTransform>();
                rt->setParent(tutBase->getComponentPtr<RectTransform>());
                rt->getSizeModifiable() = {250, 180};
                rt->getAnchorModifiable() = {0.0f, 0.0f};
                rt->getLocalPositionModifiable() = {0.0f, -10.0f};
            
            auto uir = objectModule.newEmptyComponentForLastEntity<UiRenderer>();
                uir->material = objectModule.newMaterial(objectModule.getShaderPtrByName("UiStandard"), "tutorial_pad", RenderType::Transparent);
                uir->material->setVec4("color", {1.0f, 1.0f, 1.0f, 0.8f});
                uir->material->setTexture("sprite", basic);
        }

        objectModule.newEntity(2, "Tutorial_text");
        {
            auto rt = objectModule.newEmptyComponentForLastEntity<RectTransform>();
                rt->setParent(tutBase->getComponentPtr<RectTransform>());
                rt->getSizeModifiable() = {0.18f, 0.18f};
                rt->getAnchorModifiable() = {0.0f, 0.0f};
                rt->getLocalPositionModifiable() = {-160.0f, 100.0f};
            
            auto tr = objectModule.newEmptyComponentForLastEntity<TextRenderer>();
                tr->material = objectModule.newMaterial(textShader, "tutorial_text", RenderType::Transparent);
                tr->material->setVec4("color", {0.0f, 0.0f, 0.0f, 1.0f});
                tr->mesh.font = courier;
                tr->mesh.text = "How to paddle the kayak";
        }

        objectModule.newEntity(2, "Tutorial_text_2");
        {
            auto rt = objectModule.newEmptyComponentForLastEntity<RectTransform>();
                rt->setParent(tutBase->getComponentPtr<RectTransform>());
                rt->getSizeModifiable() = {0.15, 0.15};
                rt->getAnchorModifiable() = {0.0f, 0.0f};
                rt->getLocalPositionModifiable() = {-108.0f, -120.0f};
            
            auto tr = objectModule.newEmptyComponentForLastEntity<TextRenderer>();
                tr->material = objectModule.newMaterial(textShader, "tutorial_text", RenderType::Transparent);
                tr->mesh.font = courier;
                tr->mesh.text = "(Press L1 to close)";
        }
    }
}

// ENEMY
{
    {
        //temporary enemy model
        objectModule.newModel("Resources/Models/Box.FBX");
        
        auto* enemy = objectModule.getEntityPtrByName("Box.FBX/Box001");
        {
            auto* t = enemy->getComponentPtr<Transform>();
                t->getLocalPositionModifiable() = {-196.0f, 20.0f, 240.0f};
                t->getLocalScaleModifiable() = {2.5f, 5.0f, 2.5f};
                t->setParent(&sceneModule.rootNode);
            auto* e = objectModule.newEmptyComponent<Enemy>();
                e->detectionCounterMaxValue = 500;
                e->sightDistance = 55.0f;
                e->sightAngle = glm::pi<float>() / 4.0f;
                enemy->addComponent(e);
            auto* a = objectModule.newEmptyComponent<EnemyAnimation>();
                a->lerpParameter = 0.25f;
                a->shootTrailTime = 0.05f;
                enemy->addComponent(a);
            auto* mr = enemy->getComponentPtr<MeshRenderer>();
                mr->material = objectModule.getMaterialPtrByName("KULA");
        
            auto* ea = objectModule.newEmptyComponent<EnemyAttack>();
                ea->activationValue = 30;
                ea->incrementValue = 1;
                ea->handicap = 5;
                ea->successChance = 0.1f;
                enemy->addComponent(ea);
        }
        // shoot trail
        objectModule.newModel("Resources/Models/BoneBox.FBX");
        
        auto* shootTrail = objectModule.getEntityPtrByName("BoneBox.FBX/Box001");
        {
            auto* t = shootTrail->getComponentPtr<Transform>();
                t->getLocalPositionModifiable() = {NAN, NAN, NAN};
                t->getLocalScaleModifiable() = {0.03f, 0.03f, 1000.0f};
                //t->setParent(enemy->getComponentPtr<Transform>());
                t->setParent(&sceneModule.rootNode);
            auto* mr = shootTrail->getComponentPtr<MeshRenderer>();
                mr->material = objectModule.getMaterialPtrByName("KULA");
            auto* st = objectModule.newEmptyComponent<Shoot>();
                shootTrail->addComponent(st);
        }
    }
}

//END TRIGGER
{
    objectModule.newEntity(3, "Finish");
    auto* t = objectModule.newEmptyComponentForLastEntity<Transform>();
        t->setParent(&sceneModule.rootNode);
        t->getLocalPositionModifiable() = {-64.0f, 0.0f, 320.0f};
        t->getLocalRotationModifiable() = glm::angleAxis(glm::radians(30.0f), glm::vec3(0.0f, 1.0f, 0.0f));
    auto* f = objectModule.newEmptyComponentForLastEntity<Finish>();
    auto* rb = objectModule.newEmptyComponentForLastEntity<Rigidbody>();
        rb->type = rp3d::BodyType::STATIC;
    auto* bc = objectModule.newEmptyComponentForLastEntity<BoxCollider>();
        bc->halfSize = glm::vec3(3.0f, 4.5f, 22.5f);
        bc->isTrigger = true;
}

// TextureCreateInfo i = {};
// i.minFilter = GL_LINEAR;
// i.magFilter = GL_LINEAR;
// i.wrapMode= GL_CLAMP_TO_EDGE;
// i.generateMipmaps = false;
// CubemapHdr* hdrCubemap = objectModule.newHdrCubemap(i,  "Resources/Textures/skybox_02/nz.hdr", 
//                                                         "Resources/Textures/skybox_02/nx.hdr", 
//                                                         "Resources/Textures/skybox_02/px.hdr",
//                                                         "Resources/Textures/skybox_02/pz.hdr",
//                                                         "Resources/Textures/skybox_02/py.hdr",
//                                                         "Resources/Textures/skybox_02/ny.hdr");

// Shader* skyboxShader = objectModule.newShader("skyboxShader", "Resources/Shaders/SkyboxCubemap/SkyboxCubemap.vert", "Resources/Shaders/SkyboxCubemap/SkyboxCubemap.frag");

// Material* hdrSkyboxMat = objectModule.newMaterial(skyboxShader, "skyboxHdrMat", RenderType::Opaque);
// hdrSkyboxMat->setTexture("cubemap", hdrCubemap);
// rendererModule.setSkybox(hdrSkyboxMat);
