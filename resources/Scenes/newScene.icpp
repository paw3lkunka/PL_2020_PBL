
auto standardPbrShader = objectModule.newShader("standardPbr", "Resources/Shaders/StandardPBR/StandardPBR.vert", "Resources/Shaders/StandardPBR/StandardPBR.frag");
auto flowmapShader = objectModule.newShader("flowmapShader", "Resources/Shaders/FlowmapWater/FlowmapWater.vert", "Resources/Shaders/FlowmapWater/FlowmapWater.frag");

TextureCreateInfo texCreateInfo = {};
texCreateInfo.generateMipmaps = true;
texCreateInfo.magFilter = GL_LINEAR;
texCreateInfo.minFilter = GL_LINEAR_MIPMAP_LINEAR;
texCreateInfo.wrapMode = GL_REPEAT;

auto water1Diffuse = objectModule.newTexture("Resources/Textures/water/Water_001_COLOR.png", texCreateInfo);
auto water1Normal = objectModule.newTexture("Resources/Textures/water/Water_001_NORM.png", texCreateInfo);
auto water1OccRouSpec = objectModule.newTexture("Resources/Textures/water/Water_001_OccRouSpec.png", texCreateInfo);
auto flowmap = objectModule.newTexture("Resources/Flowmaps/flowmap.png", texCreateInfo);
auto noise = objectModule.newTexture("Resources/Flowmaps/noiseTexture.png", texCreateInfo);

Material* waterMat = objectModule.newMaterial(flowmapShader, "waterMat", RenderType::Transparent);
waterMat->setTexture("diffuse", water1Diffuse);
waterMat->setTexture("normal", water1Normal);
waterMat->setTexture("occRouMet", water1OccRouSpec);
waterMat->setTexture("flowMap", flowmap);
waterMat->setVec2("channelFlowDirection", {-1.0f, 1.0f});
waterMat->setFloat("blendCycle", 1.0f);
waterMat->setFloat("cycleSpeed", 1.0f);
waterMat->setFloat("flowSpeed", 0.5f);
waterMat->setTexture("flowMapNoise", noise);
waterMat->setVec2("flowNoiseSize", {1.0f, 1.0f});
waterMat->setFloat("flowNoiseInfluence", 0.5f);
waterMat->setVec2("uvScale", {1.0f, 1.0f});

objectModule.newModel("Resources/Models/Plane.obj");
{
    Entity* waterPlane0 = objectModule.getEntityPtrByName("Plane.obj/mesh0");
    auto mr = waterPlane0->getComponentPtr<MeshRenderer>();
        mr->material = waterMat;

    auto t = waterPlane0->getComponentPtr<Transform>();
        t->getLocalPositionModifiable() = {50.0f, 0.0f, -50.0f};
}

// objectModule.newModel("Resources/Models/Unity/Conifer Bare BOTD LOD1.obj");

// Entity* leaves = objectModule.newEntity(2, "leaves");
// {
//     auto t = objectModule.newEmptyComponentForLastEntity<Transform>();
//         t->setParent(&sceneModule.rootNode);

//     auto mr = objectModule.newEmptyComponentForLastEntity<MeshRenderer>();
//         mr->mesh = objectModule.getMeshCustomPtrByPath("Resources/Models/Unity/Conifer Bare BOTD LOD1.obj/Conifer Leaves BODT");
// }

TextureCreateInfo i = {};
i.minFilter = GL_LINEAR;
i.magFilter = GL_LINEAR;
i.wrapMode= GL_CLAMP_TO_EDGE;
i.generateMipmaps = false;
CubemapHdr* hdrCubemap = objectModule.newHdrCubemap(i,  "Resources/Textures/skybox_02/nz.hdr", 
                                                        "Resources/Textures/skybox_02/nx.hdr", 
                                                        "Resources/Textures/skybox_02/px.hdr",
                                                        "Resources/Textures/skybox_02/pz.hdr",
                                                        "Resources/Textures/skybox_02/py.hdr",
                                                        "Resources/Textures/skybox_02/ny.hdr");

Shader* skyboxShader = objectModule.newShader("skyboxShader", "Resources/Shaders/SkyboxCubemap/SkyboxCubemap.vert", "Resources/Shaders/SkyboxCubemap/SkyboxCubemap.frag");

Material* hdrSkyboxMat = objectModule.newMaterial(skyboxShader, "skyboxHdrMat", RenderType::Opaque);
hdrSkyboxMat->setTexture("cubemap", hdrCubemap);

GetCore().rendererModule.setSkybox(hdrSkyboxMat);

objectModule.newEntity(2, "directionalLight");
{
    auto t = objectModule.newEmptyComponentForLastEntity<Transform>();
        t->getLocalRotationModifiable() *= glm::angleAxis(glm::radians(155.0f) , glm::vec3(0.0f, 1.0f, 0.0f));
        t->getLocalRotationModifiable() *= glm::angleAxis(glm::radians(20.0f) , glm::vec3(1.0f, 0.0f, 0.0f));
        t->setParent(&sceneModule.rootNode);

    auto l = objectModule.newEmptyComponentForLastEntity<Light>();
        l->lightType = LightType::Directional;
        l->intensity = 1.0f;
        l->color = {1.0f, 1.0f, 1.0f};
}

objectModule.newEntity(4, "Camera");
{
    auto c = objectModule.newEmptyComponentForLastEntity<Camera>();
    ViewFrustum& frustum = c->getFrustumModifiable();
        frustum.farPlane = 2500.0f;
        frustum.nearPlane = 0.1f;
        frustum.fieldOfView = 80.0f;
        frustum.aspectRatio = (float)GetCore().windowWidth / (float)GetCore().windowHeight;
        c->getProjectionModeModifiable() = CameraProjection::Perspective;

    auto t = objectModule.newEmptyComponentForLastEntity<Transform>();
        t->getLocalPositionModifiable() = glm::vec3(0.0f, 0.0f, 0.0f);
        t->setParent(&sceneModule.rootNode);

    auto li = objectModule.newEmptyComponentForLastEntity<AudioListener>();
        li->getIsCurrentModifiable() = true;
        li->getGainModifiable() = 1.0f;
        li->getVelocityModifiable();
        li->getPositionModifiable();
        li->getAtModifiable();
        li->getUpModifiable();
}

TerrainUtils::loadAllTerrainChunks();
TerrainUtils::loadExportedUnityModels();